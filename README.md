Конспект по многопоточности C++ (по cppreference.com, стандарту C++20 и книге Э. Уильемса «Практика многопоточного программирования»).

## Потоки

**Поток выполнения** (или *тред*, от англ. *thread* — нить) — это наименьшая единица выполнения программы, которой может управлять операционная система. Потоки позволяют выполнять несколько задач параллельно внутри одного процесса.

В стандартной библиотеке C++ потоки представлены двумя классами:

* `std::thread`
* `std::jthread`

При создании потока в `std::thread` и `std::jthread` аргументы функции копируются в локальное хранилище потока и передаются вызываемому объекту как r-value. Это значит, что параметры функции передаются по значению — копированием или перемещением.
Если необходимо передать аргумент по ссылке, его нужно обернуть с помощью `std::ref` или `std::cref`.

Любое значение, возвращаемое функцией потока, игнорируется. Если потоковая функция выбрасывает исключение, вызывается `std::terminate`.

Класс `std::jthread` в отличие от `std::thread`:

* автоматически вызывает `join()` в деструкторе, если тот не был вызван явно;
* поддерживает механизм остановки потока с помощью `std::stop_token`. (см. примеры в threads)

Функции для управления текущим потоком (`std::this_thread`):

* `std::this_thread::yield()` — даёт подсказку планировщику, позволяя другим потокам выполняться;
* `std::this_thread::get_id()` — возвращает идентификатор текущего потока;
* `std::this_thread::sleep_for()` — приостанавливает выполнение текущего потока как минимум на заданный промежуток времени;
* `std::this_thread::sleep_until()` — приостанавливает выполнение потока до наступления указанного момента времени.

## Мьютексы

Мьютекс в C++ (англ. *mutex*, от *mutual exclusion* — «взаимное исключение») — базовый механизм синхронизации. Он предназначен для организации взаимоисключающего доступа к общим данным из нескольких потоков с использованием барьеров памяти.

Существуют следующие основные разновидности мьютексов в C++:

- `std::mutex` — базовая реализация, обеспечивающая единственный уровень блокировки: только один поток может захватить мьютекс в данный момент времени.
- `std::recursive_mutex` — позволяет одному и тому же потоку многократно захватывать мьютекс. Это полезно в случаях, когда функция, уже захватившая мьютекс, вызывает другую функцию, которая также пытается его захватить.
- `std::shared_mutex` — поддерживает два типа захвата:  
  - **эксклюзивный** (только один поток может владеть блокировкой);  
  - **разделяемый** (несколько потоков могут одновременно владеть разделяемой блокировкой, но при этом исключается любая эксклюзивная блокировка).  

Разделяемая блокировка эффективна в сценариях, где большинство операций — чтение, а записи редки: несколько потоков могут параллельно читать данные, а при необходимости записи один поток получает эксклюзивную блокировку, временно блокируя все остальные.

### Мьютексы с таймаутом

Каждый из перечисленных типов мьютексов имеет аналоги с поддержкой попытки захвата блокировки по таймеру. Например, **`std::timed_mutex`** предоставляет дополнительный интерфейс:
- `try_lock_for` — пытается захватить мьютекс на заданном промежутке времени;
- `try_lock_until` — пытается захватить мьютекс до указанного момента времени.

### Менеджеры мьютексов

* **`std::lock_guard`** — простая RAII-оболочка над мьютексом, автоматически захватывающая его при создании и освобождающая при выходе из области видимости. Предназначена для кратковременного владения мьютексом без возможности управления блокировкой вручную.

* **`std::scoped_lock`** — универсальный RAII-менеджер, который может одновременно захватывать несколько мьютексов безопасным способом, предотвращая взаимную блокировку. Может использоваться и с одним мьютексом.

* **`std::unique_lock`** — гибкий RAII-менеджер, предоставляющий расширенный интерфейс для управления мьютексом: можно откладывать захват (`defer_lock`), временно освобождать (`unlock`), повторно захватывать (`lock`), а также передавать владение между функциями (поддерживает перемещение).

* **`std::shared_lock`** — RAII-оболочка для разделяемой блокировки (`std::shared_mutex`), позволяющая нескольким потокам одновременно читать данные, но блокирующая доступ на запись при активных читателях.

#### Типы стратегий захвата (теги для конструкторов менеджеров)

* **`std::defer_lock_t`** — не захватывать мьютекс при создании блокировки (захват выполняется позже вручную).
* **`std::try_to_lock_t`** — попытаться захватить мьютекс без ожидания (если занят — не блокироваться).
* **`std::adopt_lock_t`** — использовать уже захваченный ранее мьютекс (предполагается, что поток уже владеет им).

### Condition variables (условные переменные)

Условная переменная — это синхронизирующий примитив, который позволяет потокам ждать наступления определённого события.

- `std::condition_variable` — класс, работающий только с std::unique_lock< std::mutex >.
- `std::condition_variable_any` — Более гибкая версия, работает с любым типом блокировки, а не только с std::unique_lock< std::mutex >.
- `std::notify_all_at_thread_exit` — Специальная функция, позволяющая уведомить ожидающие потоки,
когда текущий поток полностью завершится (включая деструкторы thread-local переменных).
- `std::cv_status`— Перечисление, описывающее результат ожидания с таймаутом:

## Симафоры, защёлки, барьеры.
- `std::counting_semaphore` — семафор, ограничивающий количество одновременно выполняющихся потоков.

- `std::binary_semaphore` — частный случай счётного семафора (значения 0/1), аналог мьютекса.

- `std::latch` — одноразовый барьер синхронизации: поток(и) ждут, пока счётчик не достигнет нуля.

- `std::barrier` — многоразовый барьер: позволяет группе потоков синхронизироваться на нескольких этапах выполнения.

## Фьючерсы и асинхронные операции

Фьючерсы — это средства синхронизации, которые позволяют получить результат асинхронной операции, когда он станет доступен.
Основные механизмы в стандартной библиотеке C++:

* `std::promise`
* `std::future`
* `std::shared_future`
* `std::async`
* `std::packaged_task`

### `std::promise` и `std::future`

Эти классы используются вместе:

* **`std::promise`** — объект, в который один поток *помещает результат* вычислений;
* **`std::future`** — объект, из которого *другой поток получает результат*.

Между ними создаётся канал передачи данных «один к одному»: результат или исключение, помещённое в `promise`, становится доступным через `future`.

Если поток, владеющий `std::promise`, выбросит исключение и вызовет `set_exception()`, то вызов `get()` в `future` пробросит это исключение.

### `std::shared_future`

* Аналог `std::future`, но допускает **множественное чтение результата из разных потоков**.
* Создаётся либо напрямую, либо путём вызова `.share()` у `std::future`.
* Полезен, когда нужно раздать один результат нескольким потокам:

### `std::packaged_task` Позволяет *обернуть функцию* в асинхронную задачу, к которой можно получить `future`.
Часто используется для создания пула потоков или явного управления асинхронными задачами.

### `std::async`

Функция-обёртка, которая **запускает функцию асинхронно** и возвращает `std::future`, с помощью которого можно получить результат.

Режимы запуска:

* `std::launch::async` — запускает функцию в новом потоке;
* `std::launch::deferred` — выполняет функцию *только при вызове `get()` или `wait()`* (ленивое вычисление);
* комбинация `std::launch::async | std::launch::deferred` — реализация сама выбирает поведение.

### Поведение `get()` и `wait()`

* `get()` — блокируется до готовности результата, возвращает значение или выбрасывает исключение.
* `wait()` — просто ожидает готовности результата, но не извлекает его.
* После вызова `get()` значение можно получить **только один раз** (у `shared_future` — многократно).

## Модель памяти

