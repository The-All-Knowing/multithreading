Стандарт вводит понятия:

**Синхронизация вызовов библиотек**

Некоторые вызовы библиотек _синхронизируются с_ другими вызовами библиотек, выполняемыми в другом потоке. Например, атомарная операция записи с семантикой release синхронизируется с операцией чтения с семантикой acquire, которая получает значение из этой записи (31.4).

**Передача зависимости** между вычислениями A и B происходит в следующих случаях:

1. Значение вычисления A используется как операнд в вычислении B, за исключением случаев:
   * (7.1.1) — B является вызовом любой специализации функции std::kill_dependency
   * (7.1.2) — A является левым операндом встроенного логического И (&&) или логического ИЛИ (||)
   * (7.1.3) — A является левым операндом условного оператора (?:)
   * (7.1.4) — A является левым операндом встроенного оператора запятая (,)

2. Вычисление A записывает скалярный объект или битовое поле M, а вычисление B читает значение, записанное A в M, при условии что A упорядочено перед B

3. Для некоторого вычисления X существует цепочка зависимостей: A передаёт зависимость X, а X передаёт зависимость B

**Важное примечание**: отношение «передаёт зависимость» является подмножеством отношения «упорядочено перед» и, аналогично ему, строго внутрипоточное.

### Практические примеры

```cpp
// Пример 1: прямая зависимость
int x = 5;
int y = x + 1; // x передаёт зависимость y

// Пример 2: отсутствие зависимости
int a = 10;
std::kill_dependency(a); // зависимость прерывается

// Пример 3: условный оператор
bool condition = true;
int result = condition ? computeA() : computeB(); // computeA не передаёт зависимость computeB

// Пример 4: цепочка зависимостей
int data = 0;
int temp = data; // data -> temp
int result = temp + 1; // temp -> result
// data -> temp -> result
```

### Ключевые моменты

* Передача зависимости определяет порядок выполнения операций внутри потока
* Зависимость может быть прервана специальными конструкциями
* Логические операторы и условные выражения имеют особые правила передачи зависимостей
* Зависимости работают только внутри одного потока выполнения

Понимание передачи зависимостей важно для корректного написания многопоточного кода и оптимизации производительности программ.

**Порядок зависимостей** (dependency-ordering) между вычислениями A и B определяется следующими условиями:

1. Вычисление A упорядочено по зависимости перед вычислением B, если:
   * (8.1) — A выполняет операцию release над атомарным объектом M, и в другом потоке B выполняет операцию consume над M и читает значение, записанное A
   * (8.2) — для некоторого вычисления X существует цепочка: A упорядочено по зависимости перед X, и X передаёт зависимость B

**Важное примечание**: отношение «упорядочено по зависимости перед» аналогично отношению «синхронизируется с», но использует комбинацию release/consume вместо release/acquire.

### Практические примеры

```cpp
// Пример 1: прямая зависимость через атомарный объект
std::atomic<int> flag;

// Поток 1:
flag.store(42, std::memory_order_release);

// Поток 2:
int value = flag.load(std::memory_order_consume);

// Пример 2: цепочка зависимостей
std::atomic<bool> ready;
std::atomic<int> data;

// Поток 1:
data.store(100, std::memory_order_release);
ready.store(true, std::memory_order_release);

// Поток 2:
if (ready.load(std::memory_order_consume)) {
    int result = data.load(std::memory_order_relaxed);
}
```

### Ключевые особенности

* Порядок зависимостей обеспечивает видимость изменений между потоками
* Использует специфическую комбинацию memory_order: release/consume
* Создаёт более слабую гарантию упорядочивания, чем acquire/release
* Работает через цепочку зависимостей между вычислениями

### Рекомендации по применению

* Используйте order_consume только когда вам не требуется полная видимость всех предыдущих операций
* Помните, что consume обеспечивает только видимость зависимостей, а не всех операций
* Комбинация release/consume может быть более производительной, чем release/acquire
* Всегда проверяйте, действительно ли вам нужен именно такой тип синхронизации

Понимание порядка зависимостей важно для оптимизации многопоточных программ при сохранении корректности работы.